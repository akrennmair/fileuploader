<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Documentation for fileuploader by Andreas Krennmair</title>
	</head>
	<body>
		<h1>Documentation for fileuploader by Andreas Krennmair</h1>
		<p>
			This documentation provides information about the overall architecture and design decisions of my solution for the SoundCloud Backend Developer Challenge.
		</p>
		<p>
			My solution, dubbed fileuploader, is developed in the programming language <a href="http://golang.org/">Go</a> developed at Google. Since the language is still in flux,
			this code is built using the latest weekly snapshot, weekly.2012-01-27 at the time of writing. The frontend (i.e. the UI that is visible to the user) was implemented
			using HTML and JavaScript with no dependencies to existing libraries, while the backend (the part that receives the uploaded file and the description text and stores 
			it) was implemented in pure Go, depending on no other packages than those from the standard library. The http.Server that comes with Go's standard library is used
			as web server.
		</p>
		<h2>Structuring the Problem</h2>
		<p>
			When I first saw the challenge description, I extracted the following general application structure that would be needed:
		</p>
		<ul>
			<li>An upload page that renders the form to select a file and to save the description text</li>
			<li>A page to which the file will be POSTed as multipart/form-data</li>
			<li>A page to which the description text will be POSTed</li>
			<li>A page that returns the current upload state (if there's currently an upload going on), preferably in percent uploaded</li>
			<li>A page to directly deliver the uploaded file so that it can be redownloaded</li>
			<li>A page to show a download link and the description text for a previously uploaded file</li>
		</ul>
		<p>
			The general workflow would be:
		</p>
		<ul>
			<li>The user opens the upload page.</li>
			<li>The user selects a file for upload.</li>
			<li>The upload starts, and during the upload, the front end regularly polls for the current upload progress and displays it until the file has been fully uploaded.</li>
			<li>When the upload is finished, a download link is presented to the user.</li>
			<li>The user enters a description text and hits the save button.</li>
			<li>The user is shown a description page with a download link and the previously entered description text.</li>
		</ul>
		<h2>Distinguishing Uploads</h2>
		<p>
			The first problem I started working was how to distinguish different uploads. Since the file upload and saving the description text are two different steps, plus the 
			upload progress polling needs the identify the file upload as well, an identifier needs to be introduced so that the backend knows which specific file upload each
			request is about.
		</p>
		<p>
			In order to solve this, a reasonably unique upload ID is generated when the upload page is opened. This is the first point where security needs to be taken into
			account: since this is data sent from the client, it is untrusted. An attacker could try to guess upload IDs in order to try to find collisions to e.g.
			overwrite already uploaded files. To protect against such an attack, the server needs a mechanism to find out whether an upload ID is legitimate, i.e. that it was
			really generated by the server and not conceived by an attacker.
		</p>
		<p>
			A possibility to generate an upload ID whose authenticity can be verified is to sign it with a hash. In my implementation, I generate 64 bits of random data, then
			I hash this data with a secret key that is only known to the server (using MD5), and finally generate the upload ID by concatenating the hash and the random data.
			Using this method, verifying the authenticity of the upload ID is simple: first, we extract the random data from the upload ID, then we hash it together with the 
			secret key. If the resulting hash is equal to the hash part of the upload ID, then the upload ID is authentic, otherwise it's an invalid upload ID possibly generated
			by an attacker. The security of this method relies on two properties: that the attacker has no possibility to gain knowledge of the secret key, and that the attacker
			is unable to crack the hash function in a feasible amount of time.
		</p>
		<p>
			In the application, the upload ID is used practically with every request to identify to which upload it belongs. Except for the upload page, HTTP requests without
			upload ID or with an invalid upload ID are ignored.
		</p>
		<h2>The Upload Process</h2>
		<h3>Client Side</h3>
		<p>
			When the user opens the upload page, a file input control, a text area and a save button is shown. When the user selects a file to be uploaded, the <tt>onchange</tt>
			event of the file input control starts a JavaScript function <tt>start_upload()</tt>, which submits the file upload form to <tt>/upload/&lt;upload_id&gt;</tt>, marks that an upload has been started
			and starts polling for the upload progress. In case an upload has already been started before on the same page, a warning message is presented to the user
			and no upload is started. The file upload form is targeted to a hidden iframe. This has the effect that the file upload can work without having to reload
			the upload page.
		</p>
		<p>
			As already mentioned, <tt>start_upload()</tt> starts the polling for the upload progress. This is done using a XMLHttpRequest on <tt>/progress/&lt;upload_id&gt;</tt>,
			which in turn delivers the current upload progress in textual form. The upload progress is converted from text to an <tt>int</tt>, and if it's greater than
			the current progress, the progress view is updated. If the upload progress reached 100 %, the progress is finished (see below), otherwise the next round of
			polling the upload progress is started: every second, the upload progress is polled and displayed, until the upload is complete.
		</p>
		<p>
			When the upload progress reaches 100 %, it is displayed to the user by the function <tt>finish_progress()</tt>, and a download link to the file that has just been uploaded is presented to the user. If
			the user pressed the save button during the upload, the save description form is submitted.
		</p>
		<p>
			After initiating an upload, the user can also enter a description text, which can be saved by pressing the save button. The description text can be entered
			into an ordinary <tt>textarea</tt>. Pressing the save button runs the function <tt>save_desc()</tt> through the submit button's <tt>onclick</tt> event. This
			function then follows the following logic:
		</p>
		<ul>
			<li>If no file upload has been started yet, inform the user that he needs to select a file.</li>
			<li>If a file upload has been completed, submit the description text form to the server in order to save it.</li>
			<li>If a file upload has been started that hasn't completed yet, mark a pending save operation and disable the text area and the save button so that the description text
			can't be changed anymore and the save operation can't be accidentally triggered twice. The save operation will then be run by the <tt>finish_progress()</tt> function
			mentioned above.</li>
		</ul>
		<p>
			Submitting the text description form will POST the description to <tt>/savedesc/&lt;upload_id&gt;</tt>, which in turn will do a 302 redirect to <tt>/show/&lt;upload_id&gt;</tt>
			which presents the user with the description entered in the previous dialog and a download link.
		</p>
		<h3>Server Side</h3>
		<p>
			When user opens the upload page, the server generates an upload ID, fills it into the right placeholders of the HTML template, and sends it to the client.
		</p>
		<p>
			Next, when the user selects a file to upload, the server receives the file as a multipart/form-data encoded POST request. The server first checks whether
			it really received a POST request. Then it checks whether the provided upload ID is valid. Requests with an invalid HTTP method or an invalid upload ID
			are rejected.
		</p>
		<p>
			Then the server sets up the progress counting. This is done the following way: the multipart/form-data encoded data is parsed from the HTTP request body. In 
			order to track the progress, the <tt>io.ReaderCloser</tt> object connected with the HTTP request body is wrapped with an own implementation of the
			<tt>io.ReaderCloser</tt> interface to which the expected Content-Length is passed and which then subsequently tracks how much data has already been
			read from the HTTP request body (i.e. uploaded) and regularly updates the current upload progress.
		</p>
		<p>
			After setting up the progress counting, the actual multipart-form-data is being parsed using Go's http.MultipartReader that is part of its standard library.
			Only the first part is saved, all subsequent parts are ignored. In addition to the first file, the original filename is saved as well. When the upload 
			is finished, the server responds with an HTTP status 200.
		</p>
		<p>
			In the meanwhile, the server receives HTTP requests that poll the current upload progress. The server fetches the current upload progress, and sends
			it back to the client. Requests with invalid upload IDs are ignored, as usual.
		</p>
		<p>
			When a user saves the description text, the server receives the corresponding HTTP request. Requests with an invalid upload ID or an HTTP method other
			than POST are ignored by the server. The server then checks whether an upload with the corresponding upload ID exists (according to the client logic, the file
			will be uploaded before the description text), and if it does, the description text is saved alongside the uploaded file. The server then generates
			a redirect to a description page that shows the description text and a download link to the previously uploaded file.
		</p>
		<p>
			This description page first validates the upload ID, and then fetches the corresponding description text and original filename, and displays them alongside with the download link.
			If an upload hasn't completed yet, the server sends an HTTP 403 instead, and displays "forbidden" to the user. Displaying the description text requires
			another security consideration: both the description text and the original filename are untrusted user input and thus must be escaped accordingly,
			otherwise the application would be vulnerable to cross-site scripting (XSS), as users would be able to inject custom JavaScript code.
		</p>
		<p>
			After visiting the description page, a user may click the download link. The server again validates the specified upload ID (and rejects invalid requests)
			and checks whether the requested file has been uploaded completely. Access to incomplete uploads will be denied with an HTTP 403 and a message "forbidden".
			The server then sets the Content-Disposition header (so that the user will download the file under the same filename it has been uploaded) and the
			Content-Length header to the size of the file, and then sends to file contents to the client.
		</p>
		<h3>Storage</h3>
		<p>
			In my implementation, I chose to store both the uploaded files and the corresponding metadata (description text, upload progress, original filename) in a 
			key-value store, namely the one which practically every operating system comes with: the filesystem.
			Not only allows this a simple implementation (each operation on an entry, such as adding a new key-value pair, deleting an existing key, or updating
			the value of an existing key, maps to a few simple file operations), it also keeps practically all state about each upload out of the server.
		</p>
		<h2>Scalability</h2>
		<p>
			I designed and implemented this application with scalability in mind. Here I will briefly sketch out what I regard as ideas that help scalability.
		</p>
		<p>
			First, I made sure that no persistent state about each upload is kept in the server itself, i.e. every requests starts out with only the upload ID
			and will subsequently read or write the data it requires. All persistent state is kept in the filesystem. This allows to distribute all HTTP requests
			to different instances of the application: as long as all instances share the same filesystem, each instance can work on a request independent of
			all other instances.
		</p>
		<p>
			The upload page can then be sent from instance A, the file upload can then be sent to instance B, and the upload progress polling will go to
			instances C to G, while the description text will be saved by instance H and the description page will be rendered by instance I: since all
			instances would work on the same filesystem, the application would still work fine.
		</p>
		<p>
			The way to keep the shared filesystem scalable would be to use a technology like network-mounted filesystems (NFS comes to mind). Once the I/O load
			on one machine gets too high, the upload IDs could be used to "shard" the files over different mount points: upload IDs consist of 48 random hexadecimal 
			characters (i.e. [0-9a-f]), and e.g. a directory hierarchy based on the first hexadecimal character could be created (16 directories ranging from 0 to f),
			and the first character of the upload ID decides in which directory the uploaded file will reside. To distribute I/O load between machines, these
			16 different directories can then be mounted to different NFS shares on different machines. This scheme can be made even more elaborated, e.g. by
			also taking the second character of the upload ID into account.
		</p>
		<p>
			Another small factor that helps scalability is the way the upload ID is created and validated: both operations can be performed with no need
			to access to other parts of the infrastructure. Each instance only requires the knowledge of the secret key to indepedently verify the
			authenticity of an upload ID. No central authority whatsoever is required for these operations.
		</p>
		<h2>Known Issues</h2>
		<p>
			I am aware of the following issues in the application:
		</p>
		<ul>
			<li>
				A user can upload a file, save the description text, and from the description page, he can then use the back button to return to the upload page.
				A subsequent upload will fail though, as the previously used upload ID will be reused, which is then rejected by the server.
			</li>
		</ul>
		<h2>Future Improvements</h2>
		<ul>
			<li>Barely any automated tests exist for the application. There is a lot of room for improvement on that part.</li>
			<li>The URL routing code is a bit awkward and should be refactored.</li>
			<li>The current JavaScript code is messy, uses global variables and violates the principle of separation of code (JavaScript) and 
			presentation (HTML), mostly because I totally the experience in using JavaScript. This is an area where a lot of refactoring might be necessary.</li>
		</ul>
	</body>
</html>
